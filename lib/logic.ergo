namespace BS.app

import org.accordproject.time.*

define function checkTemperature(minTemperature : Double, maxTemperature : Double, readings : Double[]) : Boolean {
    let temperatureReadings = foreach x in readings return x;
    let lowestReading = min(temperatureReadings);
    let highestReading = max(temperatureReadings);

    if lowestReading < minTemperature
        then return false
    else if highestReading > maxTemperature
        then return false
    else return true
}

define function checkDeliveryDate(dateOfArrival : DateTime, dueDate : DateTime) : Boolean {
    if isBefore(dateOfArrival,dueDate) = true
        then return true
    else return false
}

define function penaltyCalculationUnder(isTempCorrect : Boolean, penaltyValue : Double, tempDifferenceUnder : Double) : Double {
    if isTempCorrect = false and tempDifferenceUnder > 0.0
        then return penaltyValue * tempDifferenceUnder
    else return 0.0
}

define function penaltyCalculationOver(isTempCorrect : Boolean, penaltyValue : Double, tempDifferenceAbove : Double) : Double {
    if isTempCorrect = false and tempDifferenceAbove > 0.0
        then return penaltyValue * tempDifferenceAbove
    else return 0.0
}

define function penaltyCalculationLate(isTimeCorrect : Boolean, penaltyValue : Double) : Double {
    if isTimeCorrect = false
        then return penaltyValue
    else return 0.0
}

contract temperature over temperatureReadingContract {
    clause checkDelivery(request : tempReadings) : checkContract emits output {
        let readings = request.readings;
        enforce readings !=[]
        else throw ErgoErrorResponse{message: "Received no information"};


        let low = min(readings);
        let high = max(readings);
        let avg = average(readings);

        let correctTemp = checkTemperature(contract.minTemp, contract.maxTemp, readings);
        let onTime = checkDeliveryDate(now, contract.dueDate);
        let penaltyValue = contract.penaltyAmount;
        let penaltyValueLate = contract.penaltyAmountLate;
        let tempDifferenceUnder = contract.minTemp - low;
        let tempDifferenceAbove = high - contract.maxTemp;
        let penalty = penaltyCalculationUnder(correctTemp, penaltyValue, tempDifferenceUnder) + penaltyCalculationOver(correctTemp, penaltyValue, tempDifferenceAbove) + penaltyCalculationLate(onTime, penaltyValueLate);

        emit output {
            shipmentID: contract.shipmentID,
            correctTemp: correctTemp,
            onTime: onTime,
            expectedDelivery : contract.dueDate,
            arrivalTime: now,
            tempRange : request.readings,
            maxAllowedTemp : contract.maxTemp,
            minAllowedTemp : contract.minTemp,
            highestRecordedTemp: high,
            lowestRecordedTemp: low,
            averageRecordedTemp: avg,
            finalPenalty : penalty,
            currency : contract.currencyCode
        };

        return checkContract {
            shipmentID: contract.shipmentID,
            correctTemp: correctTemp,
            onTime: onTime,
            expectedDelivery : contract.dueDate,
            arrivalTime: now,
            maxAllowedTemp : contract.maxTemp,
            minAllowedTemp : contract.minTemp,
            highestRecordedTemp: high,
            lowestRecordedTemp: low,
            averageRecordedTemp: avg,
            finalPenalty : penalty,
            currency : contract.currencyCode
        }
    }
}